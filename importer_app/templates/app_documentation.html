{% extends "base.html" %}

{% block title %}App Documentation{% endblock %}

{% block head_styles %}
<style>
    body {
        font-family: 'Inter', sans-serif; /* Using Inter font */
        background-color: #f4f7f6;
        color: #333;
    }
    .page-container {
        max-width: 95%;
        margin: 0 auto;
        padding: 20px;
        background-color: #ffffff;
        border-radius: 12px;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    }
    h1 {
        color: #012169;
        font-size: 2.5em;
        margin-bottom: 25px;
        text-align: center;
        border-bottom: 2px solid #e6ecfa;
        padding-bottom: 15px;
    }
    .actions-bar {
        display: flex;
        justify-content: flex-end;
        gap: 15px;
        margin-bottom: 30px;
        padding: 15px;
        background-color: #f9fbfd;
        border-radius: 10px;
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
    }
    .button {
        padding: 12px 25px;
        border: none;
        border-radius: 8px;
        cursor: pointer;
        font-size: 1em;
        font-weight: 600;
        transition: background-color 0.3s ease, transform 0.2s ease;
        text-decoration: none;
        display: inline-flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        background-color: #007bff;
        color: white;
    }
    .button:hover {
        background-color: #0056b3;
        transform: translateY(-2px);
    }
    .button.btn-secondary {
        background-color: #6c757d;
    }
    .button.btn-secondary:hover {
        background-color: #5a6268;
    }
    .button.btn-danger {
        background-color: #dc3545;
    }
    .button.btn-danger:hover {
        background-color: #c82333;
    }

    /* Documentation Tree Styling */
    .documentation-tree {
        padding: 0 20px;
    }
    .doc-node {
        background-color: #fff;
        border: 1px solid #e6ecfa;
        border-radius: 10px;
        padding: 20px;
        margin-bottom: 20px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        position: relative;
    }
    .doc-node.heading {
        border-left: 5px solid #002165;
    }
    .doc-node.subheading {
        margin-left: 30px;
        border-left: 5px solid #0056b3;
        background-color: #fbfdff;
    }
    .doc-node.file {
        margin-left: 60px;
        border-left: 5px solid #28a745;
        background-color: #fcfcfc;
    }

    .doc-node h3 {
        color: #012169;
        margin-top: 0;
        margin-bottom: 10px;
        font-size: 1.8em;
    }
    .doc-node h4 {
        color: #0056b3;
        margin-top: 0;
        margin-bottom: 8px;
        font-size: 1.5em;
    }
    .doc-node h5 {
        color: #28a745;
        margin-top: 0;
        margin-bottom: 6px;
        font-size: 1.2em;
    }
    /* Styles for Markdown content within .doc-node */
    .doc-node .markdown-body h3 { /* For sub-sub-headings within the markdown body */
        color: #002165; /* Darker blue for consistent look */
        font-size: 1.3em;
        margin-top: 20px;
        margin-bottom: 10px;
        border-bottom: 1px dashed #eee;
        padding-bottom: 5px;
    }
    .doc-node .markdown-body p {
        margin-bottom: 8px;
        line-height: 1.6;
        color: #555;
    }
    .doc-node .markdown-body strong {
        color: #002165;
    }
    .doc-node .meta-info {
        font-size: 0.9em;
        color: #888;
        margin-bottom: 15px;
        border-bottom: 1px dashed #eee;
        padding-bottom: 10px;
    }
    .doc-node .file-details span, .doc-node .related-files span {
        display: inline-block;
        background-color: #e6ecfa;
        color: #002165;
        padding: 4px 10px;
        border-radius: 6px;
        margin-right: 8px;
        margin-bottom: 5px;
        font-size: 0.85em;
        font-family: monospace;
        white-space: nowrap; /* Prevent breaking for paths */
    }
    .doc-node .actions {
        margin-top: 15px;
        display: flex;
        gap: 10px;
    }
    .doc-node .actions .button {
        padding: 8px 15px;
        font-size: 0.9em;
        border-radius: 6px;
    }

    /* Modal Styling */
    .modal {
        display: none;
        position: fixed;
        z-index: 1000;
        left: 0;
        top: 0;
        width: 100%;
        height: 100%;
        overflow: auto;
        background-color: rgba(0,0,0,0.6);
        animation: fadeIn 0.3s ease-out;
    }
    .modal-content {
        background-color: #fefefe;
        margin: 5% auto;
        padding: 30px;
        border: 1px solid #888;
        width: 90%;
        max-width: 800px;
        border-radius: 12px;
        box-shadow: 0 8px 25px rgba(0,0,0,0.25);
        animation: slideIn 0.3s ease-out;
    }
    .close-button {
        color: #aaa;
        float: right;
        font-size: 32px;
        font-weight: bold;
        cursor: pointer;
        transition: color 0.3s ease;
    }
    .close-button:hover, .close-button:focus {
        color: #333;
        text-decoration: none;
    }
    .modal h2 {
        color: #012169;
        margin-top: 0;
        margin-bottom: 25px;
        border-bottom: 1px solid #eee;
        padding-bottom: 15px;
        font-size: 2em;
    }
    .modal-form-group {
        margin-bottom: 20px;
    }
    .modal-form-group label {
        display: block;
        margin-bottom: 8px;
        font-weight: 600;
        color: #333;
    }
    .modal-form-group input,
    .modal-form-group textarea,
    .modal-form-group select {
        width: 100%;
        padding: 12px;
        border: 1px solid #ccc;
        border-radius: 8px;
        box-sizing: border-box;
        font-size: 1em;
        transition: border-color 0.3s ease, box-shadow 0.3s ease;
    }
    .modal-form-group input:focus,
    .modal-form-group textarea:focus,
    .modal-form-group select:focus {
        border-color: #007bff;
        box-shadow: 0 0 0 3px rgba(0, 123, 255, 0.25);
        outline: none;
    }
    .modal-form-group textarea {
        resize: vertical;
        min-height: 100px;
    }
    .modal-button-bar {
        display: flex;
        justify-content: flex-end;
        gap: 15px;
        margin-top: 30px;
        padding-top: 20px;
        border-top: 1px solid #eee;
    }

    /* Animations */
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    @keyframes slideIn {
        from { transform: translateY(-50px); opacity: 0; }
        to { transform: translateY(0); opacity: 1; }
    }

    /* Responsive adjustments */
    @media (max-width: 768px) {
        .page-container {
            padding: 15px;
        }
        h1 {
            font-size: 2em;
        }
        .actions-bar {
            flex-direction: column;
            gap: 10px;
        }
        .button {
            width: 100%;
            padding: 10px;
        }
        .doc-node.subheading {
            margin-left: 15px;
        }
        .doc-node.file {
            margin-left: 30px;
        }
        .modal-content {
            margin: 10% auto;
            padding: 20px;
        }
        .modal h2 {
            font-size: 1.5em;
            margin-bottom: 15px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="page-container">
    <a href="{{ url_for('admin.admin_dashboard') }}" class="button btn-secondary" style="margin-bottom: 20px;">&larr; Back to Admin</a>
    <h1>App Documentation Overview</h1>

    <div class="actions-bar">
        <button type="button" class="button" onclick="importDocumentation()">Import All</button>
        <button type="button" class="button" onclick="exportDocumentation()">Export All</button>
        <button type="button" class="button" onclick="openEditModal()">Add New Entry</button>
    </div>

    <div id="documentation-tree" class="documentation-tree">
        <!-- Dynamically loaded and structured content -->
        <p>Loading documentation...</p>
    </div>
</div>

<!-- Modal for Add/Edit -->
<div id="edit-doc-modal" class="modal">
    <div class="modal-content">
        <span class="close-button" onclick="closeEditModal()">&times;</span>
        <h2 id="modal-title">Add New Documentation Entry</h2>
        <div class="modal-form">
            <input type="hidden" id="edit-entry-id">

            <div class="modal-form-group">
                <label for="new-type">Entry Type:</label>
                <select id="new-type" onchange="toggleFormFields()">
                    <option value="heading">Heading</option>
                    <option value="subheading">Subheading</option>
                    <option value="file">File</option>
                </select>
            </div>

            <div class="modal-form-group" id="parent-id-group">
                <label for="new-parent-id">Parent Entry:</label>
                <select id="new-parent-id"></select>
            </div>

            <div class="modal-form-group">
                <label for="new-title">Title:</label>
                <input type="text" id="new-title" required>
            </div>

            <div class="modal-form-group" id="file-path-group">
                <label for="new-file-path">File Path:</label>
                <input type="text" id="new-file-path" placeholder="e.g., services/importer.py">
            </div>

            <div class="modal-form-group">
                <label for="new-body">Body / Description:</label>
                <textarea id="new-body" rows="6"></textarea>
            </div>

            <div class="modal-form-group" id="related-files-group">
                <label for="new-related-files">Related Files (comma-separated):</label>
                <input type="text" id="new-related-files" placeholder="e.g., index.html, styles.css">
            </div>

            <div class="modal-form-group" id="display-order-group">
                <label for="new-display-order">Display Order (for headings/subheadings):</label>
                <input type="number" id="new-display-order" value="100" min="1">
            </div>

            <div class="modal-button-bar">
                <button type="button" class="button" onclick="saveDocumentationEntry()">Save Entry</button>
                <button type="button" class="button btn-secondary" onclick="closeEditModal()">Cancel</button>
            </div>
        </div>
    </div>
</div>

<!-- Hidden file input for import -->
<input type="file" id="import-file-input" accept=".json" style="display: none;">
{% endblock %}

{% block scripts %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/marked/12.0.0/marked.min.js"></script>
<script>
    let allDocEntries = [];
    const editDocModal = document.getElementById('edit-doc-modal');
    const modalTitle = document.getElementById('modal-title');
    const editEntryId = document.getElementById('edit-entry-id');
    const newType = document.getElementById('new-type');
    const newParentIdSelect = document.getElementById('new-parent-id');
    const newTitle = document.getElementById('new-title');
    const newBody = document.getElementById('new-body');
    const newFilePath = document.getElementById('new-file-path');
    const newRelatedFiles = document.getElementById('new-related-files');
    const newDisplayOrder = document.getElementById('new-display-order');

    // Groups for toggling visibility
    const parentIdGroup = document.getElementById('parent-id-group');
    const filePathGroup = document.getElementById('file-path-group');
    const relatedFilesGroup = document.getElementById('related-files-group');
    const displayOrderGroup = document.getElementById('display-order-group');

    const importFileInput = document.getElementById('import-file-input');


    /**
     * Fetches all documentation entries from the API and renders them.
     */
    async function fetchDocumentationEntries() {
        try {
            const response = await fetch("/admin/app_documentation/api/docs");
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(`Failed to fetch documentation: ${errorText}`);
            }
            allDocEntries = await response.json();
            renderDocumentation();
        } catch (error) {
            console.error("Error fetching documentation:", error);
            document.getElementById('documentation-tree').innerHTML = `<p style="color: #dc3545;">Failed to load documentation: ${error.message}</p>`;
        }
    }

    /**
     * Saves a new or updates an existing documentation entry.
     */
    async function saveDocumentationEntry() {
        const id = editEntryId.value;
        const type = newType.value;
        const title = newTitle.value;
        const body = newBody.value; // Markdown content
        const parent_id = newParentIdSelect.value ? parseInt(newParentIdSelect.value) : null;
        const display_order = parseInt(newDisplayOrder.value);

        // Conditional fields for 'file' type
        const file_path = type === 'file' ? newFilePath.value : null;
        // Split related files by comma and trim whitespace
        const related_files_array = type === 'file' && newRelatedFiles.value
                                    ? newRelatedFiles.value.split(',').map(f => f.trim()).filter(f => f)
                                    : [];
        // Store related_files as a JSON string or null if empty
        const related_files = related_files_array.length > 0 ? JSON.stringify(related_files_array) : null;

        if (!title || !body) {
            alert('Title and Body are required.');
            return;
        }

        if (type === 'subheading' && !parent_id) {
            alert('Subheadings must have a parent Heading.');
            return;
        }
        if (type === 'file' && !parent_id) {
            alert('Files must have a parent Subheading or Heading.');
            return;
        }

        const data = {
            title: title,
            body: body,
            type: type,
            parent_id: parent_id,
            display_order: display_order,
            file_path: file_path,
            related_files: related_files
        };

        const method = id ? 'PUT' : 'POST';
        const url = id ? `/admin/app_documentation/api/docs/${id}` : '/admin/app_documentation/api/docs';

        try {
            const response = await fetch(url, {
                method: method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data)
            });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText);
            }
            alert('Entry saved successfully!');
            closeEditModal();
            fetchDocumentationEntries(); // Re-fetch to update the UI
        } catch (error) {
            alert(`Error saving entry: ${error.message}`);
            console.error("Error saving entry:", error);
        }
    }

    /**
     * Deletes a documentation entry by ID.
     * Includes a confirmation step.
     */
    async function deleteDocumentationEntry(id, type) {
        let confirmMessage = 'Are you sure you want to delete this documentation entry?';
        if (type === 'heading' || type === 'subheading') {
            confirmMessage += ' All child entries (subheadings/files) under this will also be deleted.';
        }

        // Using a custom modal for confirmation instead of window.confirm
        if (!await showCustomConfirm(confirmMessage)) {
            return;
        }

        try {
            const response = await fetch(`/admin/app_documentation/api/docs/${id}`, { method: 'DELETE' });
            if (!response.ok) {
                const errorText = await response.text();
                throw new Error(errorText);
            }
            alert('Entry deleted successfully!');
            fetchDocumentationEntries(); // Re-fetch to update the UI
        } catch (error) {
            alert(`Error deleting entry: ${error.message}`);
            console.error("Error deleting entry:", error);
        }
    }

    /**
     * Renders the documentation entries in a hierarchical tree structure.
     */
    function renderDocumentation() {
        const container = document.getElementById('documentation-tree');
        container.innerHTML = ''; // Clear previous content

        // Group entries by parent_id for easier tree building
        const entriesMap = new Map();
        allDocEntries.forEach(entry => entriesMap.set(entry.id, entry));

        const getChildren = (parentId) => {
            return allDocEntries
                .filter(entry => entry.parent_id === parentId)
                .sort((a, b) => {
                    // Sort headings/subheadings by display_order, then by title
                    if (a.type !== 'file' && b.type !== 'file') {
                        return (a.display_order || 0) - (b.display_order || 0) || a.title.localeCompare(b.title);
                    }
                    // Sort files by title only
                    return a.title.localeCompare(b.title);
                });
        };

        // Recursive function to render a node and its children
        const renderNodeAndChildren = (node, parentElement) => {
            let element;
            if (node.type === 'heading') {
                element = createEntryElement(node, 'h3', 'heading');
            } else if (node.type === 'subheading') {
                element = createEntryElement(node, 'h4', 'subheading');
            } else if (node.type === 'file') {
                element = createEntryElement(node, 'h5', 'file');
            }
            
            if (element) {
                parentElement.appendChild(element);

                // Recursively render children
                const children = getChildren(node.id);
                children.forEach(child => {
                    renderNodeAndChildren(child, element);
                });
            }
        };

        // Render top-level headings (parent_id is null)
        const topLevelHeadings = getChildren(null).filter(e => e.type === 'heading');

        if (topLevelHeadings.length === 0 && allDocEntries.length > 0) {
            container.innerHTML = `<p style="color: #6c757d;">No top-level headings found. Add a 'Heading' type entry to get started.</p>`;
        } else if (allDocEntries.length === 0) {
            container.innerHTML = `<p style="color: #6c757d;">No documentation entries yet. Click "Add New Entry" to get started!</p>`;
        }


        topLevelHeadings.forEach(heading => {
            renderNodeAndChildren(heading, container);
        });

        // Handle uncategorized items (entries with parent_id but no matching parent, or files with null parent_id)
        const uncategorized = allDocEntries.filter(entry => {
            // An entry is uncategorized if it's not a top-level heading
            // AND its parent_id doesn't point to an existing entry
            // OR if it's a file with no parent_id (should ideally have a subheading/heading parent)
            if (entry.type === 'heading' && entry.parent_id === null) return false; // Already handled as top-level
            if (entry.parent_id && !entriesMap.has(entry.parent_id)) return true; // Orphaned child
            if (entry.type === 'file' && entry.parent_id === null) return true; // File without parent
            return false;
        }).sort((a,b) => a.title.localeCompare(b.title));

        if (uncategorized.length > 0) {
            const uncatDiv = document.createElement('div');
            uncatDiv.className = 'doc-node heading'; // Use heading style for uncategorized
            uncatDiv.innerHTML = `<h3>Uncategorized Entries</h3>`;
            uncategorized.forEach(entry => {
                const entryElement = createEntryElement(entry, 'h5', 'file'); // Render as file-like for consistency
                uncatDiv.appendChild(entryElement);
            });
            container.appendChild(uncatDiv);
        }
    }

    /**
     * Creates a DOM element for a documentation entry.
     * @param {object} entry - The documentation entry data.
     * @param {string} headingTag - The HTML heading tag to use (e.g., 'h3', 'h4', 'h5').
     * @param {string} className - Additional class for styling (e.g., 'heading', 'subheading', 'file').
     * @returns {HTMLElement} The created div element.
     */
    function createEntryElement(entry, headingTag, className) {
        const entryDiv = document.createElement('div');
        entryDiv.className = `doc-node ${className}`;

        const relatedFilesArray = entry.related_files ? JSON.parse(entry.related_files) : [];
        const formattedRelatedFiles = relatedFilesArray.map(file => `<span>${file}</span>`).join('');

        // Use marked.js to convert markdown body to HTML
        const renderedBody = marked.parse(entry.body || '');

        entryDiv.innerHTML = `
            <${headingTag}>${entry.title}</${headingTag}>
            <p class="meta-info">Last Updated: ${entry.updated_at ? new Date(entry.updated_at).toLocaleString() : 'N/A'}</p>
            <div class="markdown-body">${renderedBody}</div>
            ${entry.type === 'file' && entry.file_path ? `<p class="file-details"><strong>Path:</strong> <span>${entry.file_path}</span></p>` : ''}
            ${entry.type === 'file' && relatedFilesArray.length > 0 ? `<p class="related-files"><strong>Related:</strong> ${formattedRelatedFiles}</p>` : ''}
            <div class="actions">
                <button type="button" class="button" onclick="openEditModal(${entry.id})">Edit</button>
                <button type="button" class="button btn-danger" onclick="deleteDocumentationEntry(${entry.id}, '${entry.type}')">Delete</button>
            </div>
        `;
        return entryDiv;
    }

    /**
     * Opens the edit/add modal, populating it if an ID is provided.
     */
    function openEditModal(id = null) {
        clearEditModalForm();
        populateParentSelector(newType.value); // Populate based on initial type
        
        if (id) {
            modalTitle.textContent = 'Edit Documentation Entry';
            const entry = allDocEntries.find(e => e.id === id);
            if (entry) {
                editEntryId.value = entry.id;
                newType.value = entry.type || 'heading'; // Default to heading if type is missing
                newTitle.value = entry.title || '';
                newBody.value = entry.body || ''; // Keep markdown as plain text in textarea
                newFilePath.value = entry.file_path || '';
                newDisplayOrder.value = entry.display_order || 100;
                newRelatedFiles.value = entry.related_files ? JSON.parse(entry.related_files).join(', ') : '';

                // Repopulate parent selector based on loaded entry type, then set value
                populateParentSelector(newType.value, entry.id); // Pass current ID to exclude from parent options
                if (entry.parent_id) {
                    newParentIdSelect.value = entry.parent_id;
                }
            }
        } else {
            modalTitle.textContent = 'Add New Documentation Entry';
            newType.value = 'heading'; // Default for new entries
        }
        toggleFormFields(); // Adjust fields based on selected type
        editDocModal.style.display = 'block';
    }

    /**
     * Closes the edit/add modal.
     */
    function closeEditModal() {
        editDocModal.style.display = 'none';
        clearEditModalForm();
    }

    /**
     * Clears all fields in the edit modal form.
     */
    function clearEditModalForm() {
        editEntryId.value = '';
        newType.value = 'heading'; // Reset to default
        newTitle.value = '';
        newBody.value = '';
        newFilePath.value = '';
        newRelatedFiles.value = '';
        newDisplayOrder.value = 100;
        newParentIdSelect.innerHTML = ''; // Clear parent options
    }
    
    /**
     * Toggles visibility of form fields based on the selected entry type.
     * Also repopulates the parent selector.
     */
    function toggleFormFields() {
        const type = newType.value;
        const currentEditId = editEntryId.value ? parseInt(editEntryId.value) : null;

        // Hide all conditional groups first
        parentIdGroup.style.display = 'none';
        filePathGroup.style.display = 'none';
        relatedFilesGroup.style.display = 'none';
        displayOrderGroup.style.display = 'none'; // Initially hidden, will show for heading/subheading

        if (type === 'heading') {
            displayOrderGroup.style.display = 'block';
        } else if (type === 'subheading') {
            parentIdGroup.style.display = 'block';
            displayOrderGroup.style.display = 'block';
            populateParentSelector('heading', currentEditId); // Only show headings as parents
        } else if (type === 'file') {
            parentIdGroup.style.display = 'block';
            filePathGroup.style.display = 'block';
            relatedFilesGroup.style.display = 'block';
            // Files don't typically have a display_order in this hierarchy, so hide it.
            populateParentSelector('subheading', currentEditId); // Only show subheadings as parents
        }
    }

    /**
     * Populates the parent selector based on the type of children being added/edited.
     * @param {string} childType - The type of entry whose parent is being selected (e.g., 'subheading' to show headings, 'file' to show subheadings).
     * @param {number|null} excludeId - ID of the current entry being edited, to prevent selecting itself as a parent.
     */
    function populateParentSelector(childType, excludeId = null) {
        newParentIdSelect.innerHTML = '<option value="">-- None --</option>'; // Default option

        let potentialParents = [];
        if (childType === 'subheading') {
            // Parents for subheadings are headings
            potentialParents = allDocEntries.filter(e => e.type === 'heading');
        } else if (childType === 'file') {
            // Parents for files are subheadings OR headings (allowing files directly under headings)
            potentialParents = allDocEntries.filter(e => e.type === 'subheading' || e.type === 'heading');
        }

        // Filter out the current entry if it's being edited, and its children
        if (excludeId) {
            const excludedIds = getChildrenRecursive(excludeId);
            excludedIds.push(excludeId); // Add the item itself to the exclusion list
            potentialParents = potentialParents.filter(p => !excludedIds.includes(p.id));
        }

        // Sort by display_order then title
        potentialParents.sort((a, b) => (a.display_order || 0) - (b.display_order || 0) || a.title.localeCompare(b.title));

        potentialParents.forEach(parent => {
            let prefix = '';
            if (parent.type === 'heading') prefix = 'Heading: ';
            else if (parent.type === 'subheading') prefix = 'Sub: ';

            newParentIdSelect.innerHTML += `<option value="${parent.id}">${prefix}${parent.title}</option>`;
        });
    }

    /**
     * Recursively gets all child IDs for a given parent ID.
     * Used to prevent an entry from being its own parent or a parent of its own descendants.
     * @param {number} parentId - The ID of the parent to start from.
     * @returns {Array<number>} An array of all descendant IDs.
     */
    function getChildrenRecursive(parentId) {
        let childrenIds = [];
        const directChildren = allDocEntries.filter(entry => entry.parent_id === parentId);
        directChildren.forEach(child => {
            childrenIds.push(child.id);
            childrenIds = childrenIds.concat(getChildrenRecursive(child.id));
        });
        return childrenIds;
    }


    /**
     * Exports all documentation entries as a JSON file.
     */
    function exportDocumentation() {
        const dataStr = JSON.stringify(allDocEntries, null, 4);
        const blob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'app_documentation.json';
        a.click();
        URL.revokeObjectURL(url);
        alert('Documentation exported successfully!');
    }
    
    /**
     * Triggers the hidden file input for importing documentation.
     */
    function importDocumentation() {
        importFileInput.click();
    }

    /**
     * Handles the file selection for importing documentation.
     * Reads the JSON file and sends entries to the API in a hierarchical order,
     * maintaining a mapping of old JSON IDs to new database IDs.
     */
    importFileInput.onchange = async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        if (!await showCustomConfirm(`This will import documentation entries. Existing entries with the same title and parent may be overwritten. Continue?`)) {
            event.target.value = ''; // Clear file input
            return;
        }

        const reader = new FileReader();
        reader.onload = async (e) => {
            try {
                const importedData = JSON.parse(e.target.result);
                if (!Array.isArray(importedData)) throw new Error('Invalid JSON format. Expected an array.');

                let importedCount = 0;
                let overwrittenCount = 0;
                let errorsDuringImport = [];
                const oldIdToNewIdMap = new Map(); // Map to store { old_json_id: new_db_id }

                // Sort data to ensure parents are processed before children
                // This is crucial for correctly assigning parent_ids in the database
                importedData.sort((a, b) => {
                    if (a.type === 'heading' && b.type !== 'heading') return -1;
                    if (a.type !== 'heading' && b.type === 'heading') return 1;
                    if (a.type === 'subheading' && b.type === 'file') return -1;
                    if (a.type === 'file' && b.type === 'subheading') return 1;
                    // For same types, sort by display_order, then by title
                    return (a.display_order || 0) - (b.display_order || 0) || a.title.localeCompare(b.title);
                });


                for (const entry of importedData) {
                    try {
                        const payload = {
                            title: entry.title || '',
                            body: entry.body || '',
                            type: entry.type || 'file',
                            display_order: entry.display_order || 100,
                            file_path: entry.file_path || null,
                            // Convert related_files array from JSON to JSON string for backend
                            related_files: entry.related_files ? JSON.stringify(entry.related_files) : null
                        };

                        // Resolve parent_id using the map for non-heading types
                        if (entry.parent_id !== null && oldIdToNewIdMap.has(entry.parent_id)) {
                            payload.parent_id = oldIdToNewIdMap.get(entry.parent_id);
                        } else if (entry.parent_id === null && entry.type !== 'heading') {
                            // If a non-heading type has a null parent_id, it's either intended to be uncategorized
                            // or the parent wasn't found/imported yet. For now, leave as null.
                            payload.parent_id = null;
                        } else if (entry.type === 'heading') {
                            payload.parent_id = null; // Headings don't have a parent
                        } else {
                            // If parent_id exists but not in map (e.g., parent not imported yet),
                            // log a warning and set to null to avoid breaking import.
                            errorsDuringImport.push(`Warning: Parent ID ${entry.parent_id} for '${entry.title}' not found in map. Setting parent_id to null for this entry.`);
                            payload.parent_id = null;
                        }


                        // Try to find an existing entry by title, type, and resolved parent_id for updating
                        const existing = allDocEntries.find(e => 
                            e.title === entry.title && 
                            e.type === entry.type && 
                            e.parent_id === payload.parent_id 
                        );
                        
                        const id = existing ? existing.id : null;
                        const method = id ? 'PUT' : 'POST';
                        const url = id ? `/admin/app_documentation/api/docs/${id}` : '/admin/app_documentation/api/docs';
                        
                        const response = await fetch(url, {
                            method: method, headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            const errorText = await response.text();
                            throw new Error(`Failed to save '${entry.title}': ${errorText}`);
                        }

                        const result = await response.json();
                        if (result && result.id) {
                            oldIdToNewIdMap.set(entry.id, result.id); // Store mapping for children
                        }

                        if (id) {
                            overwrittenCount++;
                        } else {
                            importedCount++;
                        }
                    } catch (entryError) {
                        errorsDuringImport.push(`Error importing entry '${entry.title || "Untitled"}': ${entryError.message}`);
                        console.error(`Error importing single entry: ${entryError}`);
                    }
                }
                
                let importSummary = `Import complete! Successfully imported ${importedCount} new entries. ${overwrittenCount} existing entries were updated.`;
                if (errorsDuringImport.length > 0) {
                    importSummary += `\n\nErrors encountered:\n${errorsDuringImport.join('\n')}`;
                    alert('Import completed with warnings/errors. Check console for details.');
                    console.error("Import errors:", errorsDuringImport);
                } else {
                    alert(importSummary);
                }
                
                fetchDocumentationEntries(); // Re-fetch to update the UI
            } catch (err) {
                alert('Import failed: ' + err.message);
                console.error("Overall import error:", err);
            } finally {
                event.target.value = ''; // Clear the file input for next use
            }
        };
        reader.readAsText(file);
    };


    // --- Custom Alert/Confirm Modals (replacing window.alert/confirm) ---
    // This is to ensure the app works within an iframe without browser dialogs.
    let customAlertDialog;
    let customConfirmDialog;
    let customConfirmResolve;

    function initCustomDialogs() {
        // Alert Dialog
        customAlertDialog = document.createElement('div');
        customAlertDialog.id = 'custom-alert-dialog';
        customAlertDialog.className = 'modal';
        customAlertDialog.innerHTML = `
            <div class="modal-content">
                <span class="close-button" onclick="customAlertDialog.style.display='none';">&times;</span>
                <h2 style="font-size: 1.5em; margin-bottom: 15px;">Message</h2>
                <p id="custom-alert-message" style="margin-bottom: 25px;"></p>
                <div class="modal-button-bar" style="justify-content: center;">
                    <button class="button" onclick="customAlertDialog.style.display='none';">OK</button>
                </div>
            </div>
        `;
        document.body.appendChild(customAlertDialog);

        // Confirm Dialog
        customConfirmDialog = document.createElement('div');
        customConfirmDialog.id = 'custom-confirm-dialog';
        customConfirmDialog.className = 'modal';
        customConfirmDialog.innerHTML = `
            <div class="modal-content">
                <span class="close-button" onclick="customConfirmDialog.style.display='none'; customConfirmResolve(false);">&times;</span>
                <h2 style="font-size: 1.5em; margin-bottom: 15px;">Confirmation</h2>
                <p id="custom-confirm-message" style="margin-bottom: 25px;"></p>
                <div class="modal-button-bar" style="justify-content: center;">
                    <button class="button" onclick="customConfirmDialog.style.display='none'; customConfirmResolve(true);">Yes</button>
                    <button class="button btn-secondary" onclick="customConfirmDialog.style.display='none'; customConfirmResolve(false);">No</button>
                </div>
            </div>
        `;
        document.body.appendChild(customConfirmDialog);

        // Override native alerts/confirms (optional, but good for consistency)
        window.alert = function(message) {
            document.getElementById('custom-alert-message').textContent = message;
            customAlertDialog.style.display = 'block';
        };
        window.confirm = function(message) {
            return new Promise(resolve => {
                document.getElementById('custom-confirm-message').textContent = message;
                customConfirmResolve = resolve;
                customConfirmDialog.style.display = 'block';
            });
        };
    }

    // Function to use the custom confirm (since window.confirm will now return a Promise)
    async function showCustomConfirm(message) {
        return await window.confirm(message);
    }
    // --- End Custom Alert/Confirm Modals ---


    // Initialize custom dialogs and fetch data when DOM is ready
    document.addEventListener('DOMContentLoaded', () => {
        initCustomDialogs();
        fetchDocumentationEntries();
        toggleFormFields(); // Initialize form fields visibility
    });
</script>
{% endblock %}
